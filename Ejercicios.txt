Hola Mundo: Crea un servidor básico en NodeJS que responda "Hola Mundo" en la raíz (/). *Se le agrego el manejo de rutas

Calculadora Simple: Desarrolla una API que reciba dos números y una operación (suma, resta, multiplicación, división) y devuelva el resultado.

Contador de Visitas: Crea un servidor que cuente el número de veces que se ha accedido a la página y muestre ese número.

Gestor de Tareas: Implementa un API RESTful para gestionar una lista de tareas con operaciones CRUD (Crear, Leer, Actualizar, Borrar).

Servidor de Archivos Estáticos: Configura un servidor que sirva archivos estáticos (HTML, CSS, JS) desde una carpeta específica.

Conversor de Monedas: Crea un API que convierta cantidades entre diferentes monedas utilizando una API externa de tasas de cambio.

Autenticación Básica: Desarrolla un sistema de autenticación simple utilizando tokens JWT para proteger rutas en tu servidor.

Chat en Tiempo Real: Implementa una aplicación de chat básica usando Socket.IO para la comunicación en tiempo real entre el cliente y el servidor.

Formulario de Contacto: Crea un formulario de contacto en un sitio web y haz que envíe los datos a tu servidor, el cual los guardará en un archivo.

Consumo de API Externa: Desarrolla una aplicación que haga una solicitud a una API externa (por ejemplo, datos del clima) y muestre la información obtenida.

--------------------------------------- FILESYSTEM ------------------------------------------------

Crear y Escribir en un Archivo:
Crea un programa que escriba un mensaje en un archivo llamado mensaje.txt.

Leer un Archivo:
Crea un programa que lea el contenido de mensaje.txt y lo muestre en la consola.

Renombrar un Archivo:
Crea un programa que renombre mensaje.txt a nuevoMensaje.txt.

Eliminar un Archivo:
Crea un programa que elimine nuevoMensaje.txt.

Listar Archivos en un Directorio:
Crea un programa que liste todos los archivos en un directorio específico.



---------------------------------------- EJERCICIOS URL -----------------------------------------------------
Ejercicio 1: Analiza una URL dada y extrae su protocolo, host, path, y parámetros de consulta. Imprime cada uno de estos componentes.

Ejercicio 2: Crea una URL a partir de un objeto que contenga el protocolo, host, path y parámetros de consulta. Asegúrate de que la URL generada sea válida.

Ejercicio 3: Dada una URL con parámetros de consulta, extrae los valores de esos parámetros y conviértelos en un objeto JavaScript. Por ejemplo, para la URL http://example.com?name=John&age=30, el objeto resultante debería ser { name: 'John', age: '30' }.

Ejercicio 4: Modifica una URL dada para cambiar su path y agregar un nuevo parámetro de consulta. Por ejemplo, cambia el path de http://example.com/oldpath a /newpath y agrega el parámetro foo=bar.

Ejercicio 5: Dada una URL con un fragmento (hash), elimina el fragmento y devuelve la URL sin él. Por ejemplo, para http://example.com/page#section, la URL resultante debería ser http://example.com/page.

Ejercicio 6: Convierte una URL relativa a una URL absoluta utilizando una URL base proporcionada. Por ejemplo, convierte /path/to/resource en http://example.com/path/to/resource utilizando http://example.com como base.

Ejercicio 7: Extrae y muestra solo el nombre del dominio de una URL completa. Por ejemplo, para http://www.example.com/path, deberías obtener www.example.com.

Ejercicio 8: Dada una URL completa y un objeto de parámetros, construye una nueva URL que incluya esos parámetros adicionales. Por ejemplo, si tienes http://example.com/path y el objeto { foo: 'bar' }, la nueva URL debería ser http://example.com/path?foo=bar.

Ejercicio 9: Implementa una función que tome una URL completa y devuelva un objeto con los componentes protocol, host, pathname, y search de la URL.

Ejercicio 10: Extrae y decodifica los parámetros de consulta de una URL que contiene valores codificados en URL. Por ejemplo, para http://example.com/?name=John%20Doe&age=30, el objeto resultante debería ser { name: 'John Doe', age: '30' }.



Ejercicio: Servidor de Redirección de URLs Cortas
Descripción:
Vas a crear un servidor en Node.js que funcione como un acortador de URLs, similar a servicios como Bit.ly. 
El servidor debe:
Guardar una URL original y devolver una URL corta:

Al enviar una solicitud POST a /shorten, el servidor recibirá una URL original y generará una clave corta única (por ejemplo, una cadena de 6 caracteres alfanuméricos).
El servidor debe devolver la URL corta que incluye la clave generada, la cual será utilizada para redireccionar a la URL original.
Redirigir la URL corta a la original:

Al acceder a la URL corta (por ejemplo, /abc123), el servidor debe redirigir al usuario a la URL original asociada con esa clave.
Manejo de errores:

Si se accede a una URL corta que no existe, el servidor debe devolver un error 404 con un mensaje personalizado.
Si no se envía una URL válida al intentar acortar, el servidor debe devolver un error 400 con un mensaje de error apropiado.
Almacenamiento de URLs:

Utiliza un objeto en memoria para almacenar la relación entre las claves cortas y las URLs originales (puedes expandir esto para usar una base de datos en el futuro).


----------------------------------------------- PATH ------------------------------------------------------


Obtener el nombre del archivo: Dado un string con una ruta de archivo, utiliza path.basename() para obtener solo el nombre del archivo (incluyendo su extensión).

Obtener la extensión del archivo: A partir de una ruta, usa path.extname() para determinar la extensión del archivo.

Obtener el directorio de un archivo: Dada una ruta, usa path.dirname() para extraer el directorio donde se encuentra el archivo.

Unir rutas: Utiliza path.join() para combinar varias partes de una ruta en una sola.

Ruta absoluta: Dado un directorio y un archivo, utiliza path.resolve() para generar la ruta absoluta hacia ese archivo.

Normalizar una ruta: Dada una ruta que incluye segmentos como .. o ./, usa path.normalize() para convertirla en una ruta más simple y sin redundancias.

Comparar rutas: Dadas dos rutas, usa path.relative() para encontrar la ruta relativa entre ellas.

Separar ruta en partes: Usa path.parse() para descomponer una ruta en sus partes (directorio, nombre base, extensión, etc.).

Formar una ruta desde partes: Utiliza path.format() para crear una ruta a partir de un objeto que contiene las partes de una ruta (como las obtenidas en el ejercicio anterior).

Comprobar si es absoluto: Dada una ruta, usa path.isAbsolute() para verificar si es una ruta absoluta o relativa.

---------------------------------------------- QUERYSTRING ----------------------------------------------

Convertir un objeto en una cadena de consulta: Dado un objeto con varias propiedades, usa querystring.stringify() para convertirlo en una cadena de consulta (query string).

Parsear una cadena de consulta: Dada una cadena de consulta, utiliza querystring.parse() para convertirla en un objeto de JavaScript.

Codificar una cadena: Usa querystring.escape() para codificar una cadena de texto, convirtiendo caracteres especiales en su representación de escape.

Decodificar una cadena: Dada una cadena codificada, usa querystring.unescape() para decodificarla, devolviendo los caracteres originales.

Manejo de parámetros duplicados: Dada una cadena de consulta con parámetros duplicados, usa querystring.parse() para ver cómo se manejan los valores duplicados.

Agregar parámetros a una URL existente: Dada una URL con una cadena de consulta, usa querystring.stringify() para agregar nuevos parámetros sin sobrescribir los existentes.

Modificar un parámetro en una cadena de consulta: Dada una cadena de consulta, utiliza querystring.parse() para modificar uno de sus parámetros y luego conviértela de nuevo a una cadena usando querystring.stringify().

Eliminar un parámetro de una cadena de consulta: Dada una cadena de consulta, elimina un parámetro específico y vuelve a convertir el objeto resultante en una cadena de consulta.

Manejo de caracteres especiales en los valores: Usa querystring.stringify() y querystring.parse() para trabajar con valores que contienen caracteres especiales (por ejemplo, &, =, %).

Convertir un objeto con arreglos en una cadena de consulta: Dado un objeto con propiedades que contienen arreglos, usa querystring.stringify() para ver cómo se manejan los valores de los arreglos en la cadena de consulta


------------------------------------------------- CRYPTO ------------------------------------------------- 

Generar un Hash SHA-256:
Escribe un script que tome una cadena de texto como entrada y genere su hash utilizando el algoritmo SHA-256.

Comparar contraseñas hash:
Crea una función que reciba una contraseña en texto plano y su versión hasheada, y verifique si coinciden utilizando el algoritmo SHA-512.

Encriptar y desencriptar un mensaje con AES:
Utiliza el algoritmo de encriptación simétrica AES-256-CBC para encriptar un mensaje. Luego, escribe otro script que desencripte el mensaje cifrado y recupere el texto original.

Generar un par de claves pública y privada RSA:
Genera un par de claves RSA (pública y privada) utilizando crypto.generateKeyPairSync() y guárdalas en archivos separados.

Firmar un mensaje digitalmente:
Firma un mensaje utilizando una clave privada RSA y verifica la firma utilizando la clave pública correspondiente.

Crear un token seguro para autenticación:
Genera un token aleatorio y seguro utilizando crypto.randomBytes() para ser utilizado en un sistema de autenticación.

Derivar una clave de una contraseña:
Deriva una clave segura a partir de una contraseña usando el algoritmo PBKDF2 y genera un hash que incluya una sal aleatoria.

Encriptación y desencriptación con claves derivadas:
Utiliza la clave derivada en el enunciado anterior para encriptar y luego desencriptar un archivo de texto.

Validar la integridad de un archivo:
Calcula el hash de un archivo utilizando SHA-1 y luego verifica que el archivo no haya sido modificado comparando el hash calculado con un hash preexistente.

Generar y verificar un HMAC:
Crea un HMAC (Hash-based Message Authentication Code) utilizando SHA-256 para un mensaje dado, y luego escribe un script que verifique la integridad del mensaje usando el HMAC.



--------------------------------------------- EVENTS ---------------------------------------------------- 

Emisión y Escucha Básica:
Crea un EventEmitter, emite un evento llamado saludo y escucha ese evento para imprimir un mensaje en la consola.

Emitir con Argumentos:
Emite un evento llamado sumar que reciba dos números como argumentos, y luego escucha el evento para sumar los números e imprimir el resultado.

Manejo de Múltiples Eventos:
Crea un EventEmitter que maneje dos eventos diferentes: encender y apagar. Imprime un mensaje diferente para cada evento cuando se emitan.

Escuchar un Evento una Única Vez:
Emite un evento llamado bienvenida que solo se escuche una vez utilizando el método once. Asegúrate de que, aunque emitas el evento varias veces, solo se escuche una vez.

Contador de Eventos:
Crea un EventEmitter que cuente cuántas veces se ha emitido un evento llamado click. Imprime el número de veces que el evento ha sido emitido cada vez que se emite.

Encadenamiento de Listeners:
Emite un evento llamado procesar que pase por tres listeners diferentes, cada uno realizando una operación sobre un valor inicial. El primer listener multiplica el valor por 2, el segundo le suma 10, y el tercero imprime el resultado final.

Propagación de Errores:
Emite un evento que provoque un error y maneja ese error usando el evento error de EventEmitter.

Remover Listeners:
Crea un EventEmitter con un listener que imprima un mensaje al escuchar el evento mensaje. Luego, elimina el listener y emite el evento de nuevo para comprobar que ya no se escucha.

Herencia de EventEmitter:
Crea una clase Reloj que extienda de EventEmitter. Esta clase debe emitir un evento tic cada segundo utilizando setInterval, y un evento finalizado después de 5 segundos.

Eventos Anidados:
Crea un EventEmitter que emita un evento iniciar, el cual a su vez emita otro evento procesar. Este último debe emitir un evento finalizar cuando termine. Asegúrate de que cada evento desencadene el siguiente, y cada uno imprima un mensaje diferente.


------------------------------------------------- STREAM ------------------------------------------------- 


Lectura y escritura de archivos: Crea un programa que lea un archivo grande utilizando un Readable stream y lo copie en otro archivo utilizando un Writable stream. Asegúrate de manejar posibles errores durante el proceso.

Transformación de datos: Crea un Transform stream que reciba un archivo de texto y convierta todo el contenido a mayúsculas antes de escribirlo en un nuevo archivo.

Compresión de archivos: Escribe un programa que utilice streams para leer un archivo, comprimirlo usando zlib.createGzip(), y escribir el resultado comprimido en un nuevo archivo.

Concatenación de archivos: Crea un programa que lea múltiples archivos de texto usando Readable streams y los concatene en un único archivo de salida usando un Writable stream.

Stream de datos en tiempo real: Implementa un servidor HTTP que envíe un archivo grande de manera continua utilizando streams. El servidor debería poder manejar múltiples conexiones simultáneas sin bloquear el event loop.

Stream de datos personalizados: Crea un Readable stream personalizado que genere números del 1 al 1000 de forma secuencial y envíalos a un Writable stream que los escriba en un archivo de texto.

Filtrado de datos: Crea un Transform stream que filtre un archivo JSON de manera que solo los objetos que cumplan con ciertos criterios (por ejemplo, edad > 30) sean escritos en un nuevo archivo JSON.

Stream de línea por línea: Escribe un programa que lea un archivo de texto línea por línea usando streams y realice alguna operación en cada línea, como contar el número de palabras o caracteres.

Pipe de streams: Crea una cadena de streams donde los datos se leen de un archivo, se transforman (por ejemplo, se encriptan), y luego se escriben en otro archivo. Usa el método pipe() para conectar los streams.

Implementación de un Duplex stream: Implementa un Duplex stream personalizado que actúe como un eco, es decir, que cualquier dato escrito en él sea inmediatamente leído de nuevo.



----------------------------------------- MAS EJERCICIOS ------------------------------------------------ 

Manejo de Fechas y Tiempos con date-fns
Enunciado: Crea una función que reciba una fecha en formato string y devuelva la diferencia en días con la fecha actual utilizando el módulo date-fns.

Creación de Servidores HTTPS con https
Enunciado: Configura un servidor HTTPS básico utilizando el módulo https y sirve una página HTML simple.

Trabajando con Buffers
Enunciado: Escribe una función que convierta un string a un buffer y luego lo vuelva a convertir a un string, demostrando el uso de buffers en NodeJS.

Realizar Peticiones HTTP con axios
Enunciado: Utiliza el módulo axios para hacer una petición GET a una API pública (por ejemplo, la API de Pokémon) y muestra la respuesta en la consola.

Creación de Servidor WebSocket con ws
Enunciado: Implementa un servidor WebSocket básico utilizando el módulo ws que permita a los clientes conectarse y enviar mensajes.

Manejo de Procesos Hijos con child_process
Enunciado: Crea un script que ejecute un comando del sistema operativo (por ejemplo, ls en Unix o dir en Windows) y muestra el resultado en la consola utilizando el módulo child_process.

Compresión y Descompresión con zlib
Enunciado: Implementa funciones para comprimir y descomprimir strings utilizando el módulo zlib.

Creación de un Servidor UDP con dgram
Enunciado: Configura un servidor UDP básico que escuche en un puerto específico y responda con un mensaje predefinido utilizando el módulo dgram.

Manejo de Variables de Entorno con dotenv
Enunciado: Crea una aplicación que cargue variables de entorno desde un archivo .env utilizando el módulo dotenv y muestra estas variables en la consola.

Cifrado y Descifrado de Datos con crypto
Enunciado: Escribe funciones para cifrar y descifrar un string utilizando el módulo crypto.







